layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
g = erdos.renyi.game(num_nodes, 0.3, type=c("gnp"), directed = FALSE, loops = FALSE)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
g = erdos.renyi.game(num_nodes, 0.3, type=c("gnp"), directed = FALSE, loops = FALSE)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
g = erdos.renyi.game(num_nodes, 0.1, type=c("gnp"), directed = FALSE, loops = FALSE)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
g = erdos.renyi.game(num_nodes, 0.2, type=c("gnp"), directed = FALSE, loops = FALSE)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
#g = erdos.renyi.game(num_nodes, 0.2, type=c("gnp"), directed = FALSE, loops = FALSE)
g = barabasi.game(num_nodes)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
library(igraph)
#def number of nodes of the graph
num_nodes = 18
#Generate Graph - small world
#g = watts.strogatz.game(1, num_nodes, 2, 0.05)
#g = graph.full(num_nodes)
#g = erdos.renyi.game(num_nodes, 0.2, type=c("gnp"), directed = FALSE, loops = FALSE)
g = barabasi.game(num_nodes)
layout = layout.kamada.kawai(g)
plot (g, layout = layout)
vertices(g)
layout
rep(2, 5)
installed.packages("poibin")
installed.packages("poibin")
chooseCRANmirror()
installed.packages("poibin")
installed.packages("poibin", dependencies=True)
installed.packages("poibin", dependencies=TRUE)
installed.packages(lib.loc=NULL)
install.packages("poibin")
pnorm(0)
dnorm(0)
1norm(0)
qnorm(0)
1 / sqrt(2*pi)
library
library()
k = 0:10
k
c = c(.1, .2, .3, .4, .5)
pp = c(.1, .2, .3, .4, .5)
ppoibin(kk=kk, pp=pp, method = "DFT-CF",wts=rep(2,5))
poibin.ppoibin(kk=kk, pp=pp, method = "DFT-CF",wts=rep(2,5))
poibin
library(poibin)
poibin
ppoibin
ppoibin(kk=kk, pp=pp, method = "DFT-CF",wts=rep(2,5))
ppoibin(kk=k, pp=p, method = "DFT-CF",wts=rep(2,5))
dpoibin(kk=k, pp=p, method = "DFT-CF",wts=rep(2,5))
dpoibin(kk=k, pp=p,wts=rep(2,5))
dpoibin(kk=k, pp=p
)
dnorm(0.5)
pnorm(0.5)
dpoibin(kk=k, pp=p, wts=NULL)
dpoibin(kk=k, pp=p, wts=rep(1, 5))
dpoibin(kk=k, pp=p, wts=rep(2, 5))
dpoibin(kk=k, pp=p, wts=rep(4, 5))
help(poibin)
qpoibin(qq = 0:10/10, pp = p, wts = NULL)
qpoibin(qq = 0:10/10, pp = p, wts = rep(2, 5))
dpoibin(kk = 0:10, pp = p, wts = rep(2, 5))
ppoibin(kk = 0:10, pp = p, wts = rep(2, 5))
ppoibin(kk = 0:10/10, pp = p, wts = rep(2, 5))
k[0]
k[1]
k[10]
k[11]
k[0]
typeof(0:10)
k = 1:10
k
typeof(k)
k = c(1, 2, 3)
k
typeof(k)
pdw
summary(k)
ds = read.table("rtest.csv", sep=",",header=FALSE)
summary(ds)
ds[0]
ds[0][0]
ds[1]
ds[1][1]
ds[1][1][1]
ds[2]
ds[2][2]
ds[2][1]
k = ds[1][1]
k
k[0]
k[1]
typeof(k)
View(k)
ds <- read.table('rtest.csv', sep = ',')
ds
ds[0]
ds[1[]]
ds[1, 1]
m = ds[1, 1]
m
typeof(m)
ds[[1]]
e = ds[[2]][1]
e
e = ds[[2]]
e
e[1]
e[2]
e[3]
e[0]
help(poibin)
library(poibin)
??poibin
help(norm)
help(dnorm)
m = array(seq(1:20), dim=c(4,5))
is.matrix(m)
df = as.data.frame(m)
is.data.frame(df)
df
str(df)
is.matrix(df)
pwd
ds = read.csv('rtest.csv', sep=',', header=FALSE)
ds
ds[1,]
m = ds[1,]
m[1]
m[2]
typeof(m)
m[1] = -0.5
m[2] = 0.5
m
dnorm(m)
m
m[0]
m[1]
m[2]
n = list(m)
n
n[0]
n[1]
n[2]
dnorm(n)
n[[1]]
n[[2]]
m[[1]]
m[[2]]
m[1]
m[2]
n = list(m[[1]], m[[2]])
n
n[[1]]
n[[2]]
dnorm(n)
n = c(m[[1]], m[[2]])
dnorm(n)
m <- read.csv('rtest.csv', sep=',', header=FALSE)
m
m <- as.matrix(read.csv('rtest.csv', sep=',', header=FALSE))
m
m[1]
m[2]
m[[1]]
m[1,]
m[1, 2]
typeof(m[1,2])
m - read.csv('rtest.csv', sep=',', header=FALSE)
m = read.csv('rtest.csv', sep=',', header=FALSE)
m
typeof(m)
m[1,]
dnorm(m[1,])
dnorm(as.vector(m[1,]))
m[[1]]
m[[1,]]
dnorm(m[[1]])
typeof(m[[1]])
typeof(m[1])
as.vecotr(m[[1]])
as.vector(m[[1]])
m[[1]]
typeof(as.vector(m[[1]]))
m[1]
m[2]
m[1][1]
m[1, 2]
m[1, 1]
m[1, 3]
m[2, 1]
m[1]
m
m[1,]
m[,1]
dnorm(m[,1])
dnorm(m[1,])
m[2,]
m[1]
m
m[1][1,]
m[1][,1]
m[2][,1]
m[2]
m[1, 1]
m[1, 2]
dnorm(m[1, 1])
dnorm(m[1, 2])
dnorm(m[, 2])
dnorm(m[1,])
dnorm(m[2,])
m[2,]
m[1,]
typeof(m[1,])
typeof(m[,1])
typeof(m[2,])
m[[1]]
m[[2]]
m = read.csv('rtest.csv', sep=',', header=TRUE)
m[[1]]
m[1]
m[2]
m
typeof(m[1,])
typeof(m[,1])
mm = unlist(m[1,])
mm
typeof(mm)
m[1]
m[2]
m[1,]
m[,1]
m[,2]
dnorm(mm)
mm
typeof(mm)
unlist(mm)
typeof(mm)
dpoibin(mm)
dpoibin(mm,pp = [0.3, 0.5])
dpoibin(mm,pp = c(0.3, 0.5)
)
x = matrix(data = 1:15, nrow = 5, ncol = 5, byrow = T)
x[1]
x
x[,1]
type(x[,1])
typeof(x[,1])
typeof(x[1, ])
data = read.csv('rtest.csv', sep=',', header=FALSE)
typeof(data)
data = scan('rtest.csv', sep=',', header=FALSE)
data = scan('rtest.csv', sep=',')
typeof(data)
data
data[1]
data[1,]
data = read.csv('rtest.csv', sep=',')
data[1,]
typeof(data[1,])
data = read.csv('rtest.csv', sep=',', stringAsFactors=FALSE)
?read.table
data = read.csv('rtest.csv', sep=',', as.it = stringAsFactors)
data = read.csv('rtest.csv', sep=',', stringsAsFactors = FALSE)
data[1,]
data[,1]
data
data = read.csv('rtest.csv', sep=',', stringsAsFactors = FALSE)
data
summary(data)
data = read.csv('rtest.csv', sep=',')
data
data[1,]
data[,1]
data = read.csv('rtest.csv', sep=',')
data
t = read.csv('rtest.csv')
t
t = read.csv('rtest.csv', sep=',')
t
t = read.csv('rtest.csv', sep=',', header=FALSE)
t
t[1]
typeof(t[1,])
typeof(t[,1])
t[,1]
t[1,]
data = read.csv('rtest.csv', sep=',', stringsAsFactors=FALSE, header=FALSE)
data
data[1,]
typeof(data[1,])
typeof(data[2,])
c(data[2,])
l = c(data[1,])
l
l[[1]]
[[2]]
l[[2]]
d
t
t[1,]
l = as.vector(t[1,])
l
pnormal(l)
pnorm(l)
l = unlist(t[1,])
l
pnorm(l)
t[,1]
pnorm(t[,1])
data = read.csv('rtest.csv', sep=',', stringsAsFactors=FALSE, header=FALSE)
typeof(data)
data[1,]
typeof(data[1,])
typeof(data[,1])
library(poibin)
#Import data
mydata = read.csv('rtest.csv', sep=',', stringsAsFactors=FALSE, header=FALSE)
#Rows mydata[i, ] are 'lists', columns mydata[ , i] are 'double' or similar
#To apply poibin, on the rows, one has to create a vector by 'unlisting':
#x_i = unlist(mydata[1, ])
mydata
dpoibin(mydata[ , 1])
dpoibin(mydata[ , 1], pp = [0.1, 0.9])
dpoibin(mydata[ , 1], pp = c(0.1, 0.9)
)
dpoibin(mydata[1, ], pp = c(0.1, 0.9))
mydata[1, ]
dnorm(mydata[1,])
dpoibin(mydata[1,])
dpoibin(mydata[1,], pp = c(0.1, 0.2))
dpoibin(unlist(mydata[1, ]), pp = c(0.1, 0.9))
mydata = read.csv('rtest.csv', sep=',', stringsAsFactors=FALSE, header=FALSE)
data
mydata
mydata = read.csv('rtest.csv', sep=',', stringsAsFactors=FALSE, header=FALSE)
dpoibin(1 , pp = mydata[ , 1])
library(poibin)
dpoibin(1 , pp = mydata[ , 1])
dpoibin(2 , pp = mydata[ , 1])
real_values = c(0, 1, 2)
dpoibin(real_values , pp = mydata[ , 1])
real_values = c(0, 1, 2, 3)
dpoibin(real_values , pp = mydata[ , 1])
qpoibin(qq = c(0.05, 0.05, pp = mydata[ , 1])
()
)
qpoibin(qq = c(0.05, 0.05), pp = mydata[ , 1])
qpoibin(qq = c(0.05, 0.95), pp = mydata[ , 1])
?qnorm
qnorm(c(0.05, 0.5, 0.92))
qnorm(c(0.05, 0.5, 0.95))
# -*- coding: utf-8 -*-
"""
Created on Tue Dec  1 08:04:28 2015
Module:
bicm - Bipartite Configuration Model
Description:
Bipartite Configuartion Model. Given the input lists degree sequence
'degree_seq' and bipartite node class types 'type_seq', the module
calculates the adjacency matrix for the corresponding ensemble average
graph <G>^* with the link probabilities <G>^*_ij = p_ij.
The degrees of the nodes in the graph should correspond to the input list
degree_seq and the bipartite classes to type_seq by construction.
Author:
Mika Straka
"""
#!/usr/bin/env Rscirpt
args = commandArgs(trailingOnly = TRUE)
print(typeof(args[1])
_
library(poibin)
# Initialize with input parameters ----------------------------------------
args = commandArgs(trailingOnly = TRUE)
# Test input paramters
if (length(args) == 0) {
stop("Error, number of nodes has to be specified in Rscript call.", call.=FALSE)
} else if (length(args) > 1) {
stop("Error, too many input parameters.")
}
dim = as.integer(args[1])
print(dim)
c(1 : 3)
for (i in c(1:3)) {}
for (i in c(1:3)) {
print(i)
}
print('hi', 1)
print('hi'), 1
help(print)
print(1), print(2)
cat(paste('hi', 5))
man(poibin)
help(poibin)
??poibin
library(poibin)
??poibin
help(poibin)
dim = 1241 #as.integer(args[1])
cat(paste('...number of nodes:', dim, '\n'))
cat(paste('+++Applying Poisson Binomial distribution...', '\n'))
ig_thresh_005 = matrix( , nrow = dim, ncol = dim)
s1 = '../data/pl2/pl2_'
s2 = '.dat'
dim = 1241 #as.integer(args[1])
cat(paste('...number of nodes:', dim, '\n'))
cat(paste('+++Applying Poisson Binomial distribution...', '\n'))
setwd("~/PhD/Research_Projects/ITN/src")
# matrix with threshold values corresponding to significance level alpha = 0.05
Sig_thresh_005 = matrix( , nrow = dim, ncol = dim)
s1 = '../data/pl2/pl2_'
s2 = '.dat'
for (i in c(1:(dim-1))){
cat(paste('i:', i, '\n'))
s = paste(s1, i-1, s2, sep='')
mydata = read.csv(s, sep=',', stringsAsFactors=FALSE, header=FALSE)
#Analyze the data for i: apply poibin to each row j, which gives the probabilities
#that i and j are connected by the different
row_dim = length(mydata[ , 1])
for (j in c(1:row_dim)){
p = mydata[j, ]
#         print(p)
m_ij = c(qpoibin(qq = c(0.05), pp = p))
#         print(m_ij)
Sig_thresh_005[i, j+i] = m_ij[[1]]
}
}
#save data:
write.table(Sig_thresh_005, file = "./data/sig_thrshld_005.csv", row.names = FALSE, col.names = FALSE, sep = ";")#, na="")
cat('Done.\n')
library(poibin)
# Initialize with input parameters ---------------------------------------------
# args = commandArgs(trailingOnly = TRUE)
# if (length(args) == 0) {
#     stop("Error, number of nodes has to be specified in Rscript call.", call. = TRUE)
# } else if (length(args) > 1) {
#     stop("Error, too many input parameters.", call. = TRUE)
# }
dim = 1241 #as.integer(args[1])
cat(paste('...number of nodes:', dim, '\n'))
cat(paste('+++Applying Poisson Binomial distribution...', '\n'))
# matrix with threshold values corresponding to significance level alpha = 0.05
Sig_thresh_005 = matrix( , nrow = dim, ncol = dim)
s1 = '../data/pl2/pl2_'
s2 = '.dat'
for (i in c(1:(dim-1))){
cat(paste('i:', i, '\n'))
s = paste(s1, i-1, s2, sep='')
mydata = read.csv(s, sep=',', stringsAsFactors=FALSE, header=FALSE)
#Analyze the data for i: apply poibin to each row j, which gives the probabilities
#that i and j are connected by the different
row_dim = length(mydata[ , 1])
for (j in c(1:row_dim)){
p = mydata[j, ]
#         print(p)
m_ij = c(qpoibin(qq = c(0.05), pp = p))
#         print(m_ij)
Sig_thresh_005[i, j+i] = m_ij[[1]]
}
}
#save data:
write.table(Sig_thresh_005, file = "../data/sig_thrshld_005.csv", row.names = FALSE, col.names = FALSE, sep = ";")#, na="")
cat('Done.\n')
